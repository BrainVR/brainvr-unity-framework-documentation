{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"What it is? BrainVR unity framework is a collection of unity objects, wrappers and placeholders, that should speed up development of unity based research paradigms. Its most beneficial addition is unified logging solution that has appropriate loading scripts in the brainvr-logger-reader that are being kept updated with the changes done in the framework. The framewok also allows paring of json based settings, which makes it possible to build experiments irrespective of particular initiasiation values and removes the necessity to randomize things in Unity, which is not always a good idea. Main Features Unified logging solution for noting participant's behaviour within the experiment and ready to use scripts in R to load these logs JSON parsing modules for loading and serialising custom settings for each experiment, which allows modifying the paradigm without necessity to code new script for each different setting. Unity controllers for many objects to allow simple and fast implementation of player triggered actions, such as moving objects, playing sounds, changing materials etc. Unified Experiment framework designed to conceptualize adn enforce structure to most scientific trial based experiments. Ugly but functional Main menu to load experiments through and simple in-game menu. Canvas for displaying info throughout the experiment as well as tutorial/training information etc. Useful plugins for navigation research, networking or arduino synchronisation Is it user friendly? Unlike other solutions, this framework is not particularly user friendly. It doesnt provide many components to dragg and dropp and requires understanding of both Unity and C# to an intermediate level. You should be familiar with all that Unity offers, such as basic transform and material modifications, sounds and navigation, as well as C# concepts such as interfaces, abstract classes and delegates with events. Nevertheless, if you don't feel comfortable but would like trying it out anyway, there are already implemented projects that might help you through your first paradigm. And you can always contact us if you need any help. Why and when to use it? If you are somewhat fluent in C# and would like to work with something that is going to speed up research development in respect to logging standards and settings parsing, this framework shoudl alleviate a lot of work. It will have some learning curve to it, but many of the troublesome parts of paradigm development have been taken care of :) Quick start This framework comes with some defaults standard assets, but otherwise you should be able to include it simply in your project as a git clone. git clone https://github.com/BrainVR/brainvr-unity-framework.git Who are we? This framework has been coded by Luk\u00e1\u0161 Hejtm\u00e1nek while working at the National Institute of Mental Health and Inistitute of Physiology, ASCR. Some parts were developed in collaboration with researchers at the Center for Neuroscince at University of California, Davis. Acknowledgements","title":"Framework overview"},{"location":"#what-it-is","text":"BrainVR unity framework is a collection of unity objects, wrappers and placeholders, that should speed up development of unity based research paradigms. Its most beneficial addition is unified logging solution that has appropriate loading scripts in the brainvr-logger-reader that are being kept updated with the changes done in the framework. The framewok also allows paring of json based settings, which makes it possible to build experiments irrespective of particular initiasiation values and removes the necessity to randomize things in Unity, which is not always a good idea.","title":"What it is?"},{"location":"#main-features","text":"Unified logging solution for noting participant's behaviour within the experiment and ready to use scripts in R to load these logs JSON parsing modules for loading and serialising custom settings for each experiment, which allows modifying the paradigm without necessity to code new script for each different setting. Unity controllers for many objects to allow simple and fast implementation of player triggered actions, such as moving objects, playing sounds, changing materials etc. Unified Experiment framework designed to conceptualize adn enforce structure to most scientific trial based experiments. Ugly but functional Main menu to load experiments through and simple in-game menu. Canvas for displaying info throughout the experiment as well as tutorial/training information etc. Useful plugins for navigation research, networking or arduino synchronisation","title":"Main Features"},{"location":"#is-it-user-friendly","text":"Unlike other solutions, this framework is not particularly user friendly. It doesnt provide many components to dragg and dropp and requires understanding of both Unity and C# to an intermediate level. You should be familiar with all that Unity offers, such as basic transform and material modifications, sounds and navigation, as well as C# concepts such as interfaces, abstract classes and delegates with events. Nevertheless, if you don't feel comfortable but would like trying it out anyway, there are already implemented projects that might help you through your first paradigm. And you can always contact us if you need any help.","title":"Is it user friendly?"},{"location":"#why-and-when-to-use-it","text":"If you are somewhat fluent in C# and would like to work with something that is going to speed up research development in respect to logging standards and settings parsing, this framework shoudl alleviate a lot of work. It will have some learning curve to it, but many of the troublesome parts of paradigm development have been taken care of :)","title":"Why and when to use it?"},{"location":"#quick-start","text":"This framework comes with some defaults standard assets, but otherwise you should be able to include it simply in your project as a git clone. git clone https://github.com/BrainVR/brainvr-unity-framework.git","title":"Quick start"},{"location":"#who-are-we","text":"This framework has been coded by Luk\u00e1\u0161 Hejtm\u00e1nek while working at the National Institute of Mental Health and Inistitute of Physiology, ASCR. Some parts were developed in collaboration with researchers at the Center for Neuroscince at University of California, Davis.","title":"Who are we?"},{"location":"#acknowledgements","text":"","title":"Acknowledgements"},{"location":"getting-started/","text":"This package can be included as a git submodule, or simply donwloaded and placed in the unity asset folder. Prerequisites This framework requires Standard assets to be present, as it relies on scripts in InputManager or RigidbodyFirstPersonController . Opening a unity project with Standards assets package shoudl be enough to get you started. If needed, you can start your project from the demo project . Logging and parsing functions rely on Json.net libraries. See troubleshooting if you see any errors with these .dll files. When you are ready, open the unity and you can start modding. Preparing the scene If you cloned it through demo project, you can take a look into the Demo scene, to get the feeling of how the scene shoudl/could be organized. Otherwise, here is a list of necessary and possible objects to be included. Necessary objects Player controller needs to be in the scene. Player controller is just an abstract class you need to extend. The framwork comes with RigidBodyPlayerController which has a prefab in the Brainvr/Player folder. If not using VR, you can safely go with that. Experiment manager Experiment manager takes care of settings loading and starting up the scene. Log manager Takes care of all the logging. It resides in the Libraries folder under the brain-vr-logger. Input manager loggs and sends events about particular key presses. It's importance is mainly in conjunction with the logger. Crosshair needs to be present, even if you don't want to show it. It deals with raycasting as well, which your experiment might almost certainly need. Menu allows starting and stopping of experiment as well as returning to main menu. Optional objects Info canvas deals with displaying information on the screen. You don't have to include it if your game does not need it. Navigation manager allows to show gps like navigation on the floor or other means of navigating player. Beeper manager allows to play sounds during the experiment. Goal manager allows controlling, placement, visibility settings etc. of target destinations. Each manager controls assigned objects with a goal controller script attached. Mark manager similar to goal manager, but it doesn't implement any functions related to trigger entering etc. Arduino controller is useful if you need to send synchronisation to other devices, let's say to the EEG or EKG recordings. It is based on the Arduino iEEG controller built dll. After you have these objects in the scene, you need to implement your new experiment. Read more on the coding part later . Let's work with the demo experiment so far. Managing the experiment in scene So now you have all the objects ready, it is time to put the expriment files and settings where they belong and test out, whether we can run this thing. Managing settings It is important to understand how the experiment loading works because it is not fully straightworward. Expeirment settings are either parsed from json into SettingsHolder class or they can be inserted in the scene itself, for faster development. In the built game, only parsed settings are allowed. The parsing happens in the MainMenu scene, so if you are developping the paradigm from the game, you need to serialise your settings into asset and use that from within the scene. This allows you faster editing and testgin as well. In the experiment manager, you have parrented Settings object. This object is either empty, or holds DemoExperimentSettings asset. If it doens't, search for it and move it there. This shoudl be all :) Loading proper experiment When you play the scene, the experiment Manager will try and parse the settings and set the proper experiment with LoadExperiment function. This function searches the asset/json for the experimentName parameter and then searches the assembly for a class of that name. If it finds it, it instantiates Experiment GameOObject with the Expeirment component attached. Managing experiment Experiment does load automatically throught the manager object, but it doesn't start automatically. That is what the Menu item is for. When the experiment is loaded, Menu binds it's buttons to Experiment manager functions - start, stop etc. You can enter the menu and click on Start the experiment. If it runs, great :) You can move around and then escape and stop it. That will end the experiment and save the logs. Logging You can now take a look into the logs/ folder that resides above assets. It should contain very brief log of player activity, information about the PC settings, and lastly the exprimental procedure. If logs aren't created, check that the asset witht he settings has ShouldLog property set to true. Next steps Now you should be able to implement your first experiment. Go to new experiment to start.","title":"Getting started"},{"location":"getting-started/#prerequisites","text":"This framework requires Standard assets to be present, as it relies on scripts in InputManager or RigidbodyFirstPersonController . Opening a unity project with Standards assets package shoudl be enough to get you started. If needed, you can start your project from the demo project . Logging and parsing functions rely on Json.net libraries. See troubleshooting if you see any errors with these .dll files. When you are ready, open the unity and you can start modding.","title":"Prerequisites"},{"location":"getting-started/#preparing-the-scene","text":"If you cloned it through demo project, you can take a look into the Demo scene, to get the feeling of how the scene shoudl/could be organized. Otherwise, here is a list of necessary and possible objects to be included.","title":"Preparing the scene"},{"location":"getting-started/#necessary-objects","text":"Player controller needs to be in the scene. Player controller is just an abstract class you need to extend. The framwork comes with RigidBodyPlayerController which has a prefab in the Brainvr/Player folder. If not using VR, you can safely go with that. Experiment manager Experiment manager takes care of settings loading and starting up the scene. Log manager Takes care of all the logging. It resides in the Libraries folder under the brain-vr-logger. Input manager loggs and sends events about particular key presses. It's importance is mainly in conjunction with the logger. Crosshair needs to be present, even if you don't want to show it. It deals with raycasting as well, which your experiment might almost certainly need. Menu allows starting and stopping of experiment as well as returning to main menu.","title":"Necessary objects"},{"location":"getting-started/#optional-objects","text":"Info canvas deals with displaying information on the screen. You don't have to include it if your game does not need it. Navigation manager allows to show gps like navigation on the floor or other means of navigating player. Beeper manager allows to play sounds during the experiment. Goal manager allows controlling, placement, visibility settings etc. of target destinations. Each manager controls assigned objects with a goal controller script attached. Mark manager similar to goal manager, but it doesn't implement any functions related to trigger entering etc. Arduino controller is useful if you need to send synchronisation to other devices, let's say to the EEG or EKG recordings. It is based on the Arduino iEEG controller built dll. After you have these objects in the scene, you need to implement your new experiment. Read more on the coding part later . Let's work with the demo experiment so far.","title":"Optional objects"},{"location":"getting-started/#managing-the-experiment-in-scene","text":"So now you have all the objects ready, it is time to put the expriment files and settings where they belong and test out, whether we can run this thing.","title":"Managing the experiment in scene"},{"location":"getting-started/#managing-settings","text":"It is important to understand how the experiment loading works because it is not fully straightworward. Expeirment settings are either parsed from json into SettingsHolder class or they can be inserted in the scene itself, for faster development. In the built game, only parsed settings are allowed. The parsing happens in the MainMenu scene, so if you are developping the paradigm from the game, you need to serialise your settings into asset and use that from within the scene. This allows you faster editing and testgin as well. In the experiment manager, you have parrented Settings object. This object is either empty, or holds DemoExperimentSettings asset. If it doens't, search for it and move it there. This shoudl be all :)","title":"Managing settings"},{"location":"getting-started/#loading-proper-experiment","text":"When you play the scene, the experiment Manager will try and parse the settings and set the proper experiment with LoadExperiment function. This function searches the asset/json for the experimentName parameter and then searches the assembly for a class of that name. If it finds it, it instantiates Experiment GameOObject with the Expeirment component attached.","title":"Loading proper experiment"},{"location":"getting-started/#managing-experiment","text":"Experiment does load automatically throught the manager object, but it doesn't start automatically. That is what the Menu item is for. When the experiment is loaded, Menu binds it's buttons to Experiment manager functions - start, stop etc. You can enter the menu and click on Start the experiment. If it runs, great :) You can move around and then escape and stop it. That will end the experiment and save the logs.","title":"Managing experiment"},{"location":"getting-started/#logging","text":"You can now take a look into the logs/ folder that resides above assets. It should contain very brief log of player activity, information about the PC settings, and lastly the exprimental procedure. If logs aren't created, check that the asset witht he settings has ShouldLog property set to true.","title":"Logging"},{"location":"getting-started/#next-steps","text":"Now you should be able to implement your first experiment. Go to new experiment to start.","title":"Next steps"},{"location":"logging/","text":"Logging in the framework is handled by the brainvr-unity-logger package. There are several forced and several optional logging modules that you can implement in your experiment. Every experiment is output in a simillar manner, with specific parts distinguished by *** and ended by ---. Example ***SESSION HEADER*** { \"Participant\": \"NEO\", \"Timestamp\": \"16-01-20-13-09-2017\" } ---SESSION HEADER--- Anything below these sections is the log itself, which Logs are flagged with the participant id and time at which they were created. They also get saved in a folder, which is flagged with the id and the date at which they were created. This allows all logs from the same participant and the same day to be grouped together, but also keep the progressive informaation if multiple tests were made during that particpar day. Main logging classses Master log Responsible for handeling and keeping track of all the logs that are happening. Turning logging on and off, instantiating logs etc. should be done through Master log. Functions Variable Purpose Instantiate Sets the obejct rotation with the Quaternion. StartLogging If the object is rotating, stops the rotation. StopLogging If the object is rotating, stops the rotation. CloseLogs If the object is rotating, stops the rotation. Player log Player log logs player information as is sent to him from IPlayerController inferface. IPlayerController this interface forces each player controller to implement custom header and custom player informatino to log. This is because some VR or 2D games might require different infomration to be passed and logged, so the reponsibility to log it properly is based on the player controller that is used. Property Type Purpose HeaderLine string what will be the header line of the log PlayerInformation List<string> List of strings of values corresponsing to the HeaderLine Experiment info log Test log Optional logging classes Results","title":"Logging"},{"location":"logging/#main-logging-classses","text":"","title":"Main logging classses"},{"location":"logging/#master-log","text":"Responsible for handeling and keeping track of all the logs that are happening. Turning logging on and off, instantiating logs etc. should be done through Master log.","title":"Master log"},{"location":"logging/#functions","text":"Variable Purpose Instantiate Sets the obejct rotation with the Quaternion. StartLogging If the object is rotating, stops the rotation. StopLogging If the object is rotating, stops the rotation. CloseLogs If the object is rotating, stops the rotation.","title":"Functions"},{"location":"logging/#player-log","text":"Player log logs player information as is sent to him from IPlayerController inferface.","title":"Player log"},{"location":"logging/#iplayercontroller","text":"this interface forces each player controller to implement custom header and custom player informatino to log. This is because some VR or 2D games might require different infomration to be passed and logged, so the reponsibility to log it properly is based on the player controller that is used. Property Type Purpose HeaderLine string what will be the header line of the log PlayerInformation List<string> List of strings of values corresponsing to the HeaderLine","title":"IPlayerController"},{"location":"logging/#experiment-info-log","text":"","title":"Experiment info log"},{"location":"logging/#test-log","text":"","title":"Test log"},{"location":"logging/#optional-logging-classes","text":"","title":"Optional logging classes"},{"location":"logging/#results","text":"","title":"Results"},{"location":"plugins/","text":"Plugins are extensions that build on the framework but add you extra functionality should you require that. The main plugins are for navigation research, networking capabilities, arduino synchronisation or visual scripting. Navigation Github repository Arduino Github repository Networking Github repository","title":"Plugins"},{"location":"plugins/#navigation","text":"Github repository","title":"Navigation"},{"location":"plugins/#arduino","text":"Github repository","title":"Arduino"},{"location":"plugins/#networking","text":"Github repository","title":"Networking"},{"location":"troubleshooting/","text":"FAQ Q: Newtonsoft namespace cannot be found? A: This is most commonly caused by the default settings of the unity player to use .NET 2.0 subset, rather than full 2.0. Change that settings in the Edit/Project Settings/Player. If you still have issues, it is possible something went wrong with cloning of .dll file. Grab new one from newtonsoft and replace the bad one.","title":"Troubleshooting"},{"location":"troubleshooting/#faq","text":"Q: Newtonsoft namespace cannot be found? A: This is most commonly caused by the default settings of the unity player to use .NET 2.0 subset, rather than full 2.0. Change that settings in the Edit/Project Settings/Player. If you still have issues, it is possible something went wrong with cloning of .dll file. Grab new one from newtonsoft and replace the bad one.","title":"FAQ"},{"location":"experiment/class/","text":"StartExperiment void StartExperiment() Can only bve called if the experiment is not in Running state. FinishExperiment void FinishExperiment()","title":"API"},{"location":"experiment/class/#startexperiment","text":"void StartExperiment() Can only bve called if the experiment is not in Running state.","title":"StartExperiment"},{"location":"experiment/class/#finishexperiment","text":"void FinishExperiment()","title":"FinishExperiment"},{"location":"experiment/flow/","text":"As you read in previous chapter , each new expeirment inherits from the BrainVR.UnityFramework.Expeirments.Experiment class. This class has a certain logic and flow that is described below. Experiment flow Each experiment is separated to following phases: ExperimentInitialise ExperimentSetup ExperimentStart ExperimentFinish ExperimentClose Trials run only after Expeirment is started and before it is finished. Initialisation and setup are used for instantiating oobjects and setups that need to be done in certain order. We provide two separate functions just in case somebody needs it. Unlike Trial functions, expeirment functions cannot be run separately, they are run in blocks of 1-3 and 4-5 with StartExperiment and FinishExpeirment functions. You don't necessarilly need to use FinishExpeirment function, as the experiment finishes automatically if the CheckForEnd() function evaluates to true. Each stage has OnExperiment[Setup/Start ..] and `AfterExperiment[Setup/Start..] abstract functions that need to be implemented. These functions can remain empty, but Experiment will call them during execution. Example: private void ExperimentSetup () { OnExperimentSetup (); if ( ShouldLog ) StartLogging (); SendExperimentStateChanged ( ExperimentState . WaitingToStart ); ExperimentState = ExperimentState . WaitingToStart ; AfterExperimentSetup (); } You can see that the Experiment setup function will eventually call both OnExperimentSetup and AfterExperimentSetup functions so your child needs to implement them. usually On fuynction is called in the very beginning, and After functino at an end, but there are some exceptions that should make things cascade less violently. E.g. experimentStart calls AfterExpeirmentStart function before calling TrialSetup . this is because otherwise trial would be already already setup, when the callback would return to the function and started calling After function. If these exceptions or other positioning causes problems with timing, feel free to change the order in the Experiment class. Trial flow Each Trial is set to following stages Setup Start Finish Close Each stage has OnTrial[Setup/Start ..] and AfterTrial[Setup/Start ..] functions that need to be implemented in a similar way as the expeirment does. Force finishing trial I provide special case for skipping or force finishing trials. Because sometimes quitting trial in a middle can have unexpected effects (for example you subscribed to an event and never unsubscribed, because that happens before trial is finished). Function TrialSetNext(int trialNumber) force finishes a trial. Default virtual behaviour is to FinishTrial() , but you can override this. Don't forget to FinishTrial() in the override (or call base);","title":"Flow"},{"location":"experiment/flow/#experiment-flow","text":"Each experiment is separated to following phases: ExperimentInitialise ExperimentSetup ExperimentStart ExperimentFinish ExperimentClose Trials run only after Expeirment is started and before it is finished. Initialisation and setup are used for instantiating oobjects and setups that need to be done in certain order. We provide two separate functions just in case somebody needs it. Unlike Trial functions, expeirment functions cannot be run separately, they are run in blocks of 1-3 and 4-5 with StartExperiment and FinishExpeirment functions. You don't necessarilly need to use FinishExpeirment function, as the experiment finishes automatically if the CheckForEnd() function evaluates to true. Each stage has OnExperiment[Setup/Start ..] and `AfterExperiment[Setup/Start..] abstract functions that need to be implemented. These functions can remain empty, but Experiment will call them during execution. Example: private void ExperimentSetup () { OnExperimentSetup (); if ( ShouldLog ) StartLogging (); SendExperimentStateChanged ( ExperimentState . WaitingToStart ); ExperimentState = ExperimentState . WaitingToStart ; AfterExperimentSetup (); } You can see that the Experiment setup function will eventually call both OnExperimentSetup and AfterExperimentSetup functions so your child needs to implement them. usually On fuynction is called in the very beginning, and After functino at an end, but there are some exceptions that should make things cascade less violently. E.g. experimentStart calls AfterExpeirmentStart function before calling TrialSetup . this is because otherwise trial would be already already setup, when the callback would return to the function and started calling After function. If these exceptions or other positioning causes problems with timing, feel free to change the order in the Experiment class.","title":"Experiment flow"},{"location":"experiment/flow/#trial-flow","text":"Each Trial is set to following stages Setup Start Finish Close Each stage has OnTrial[Setup/Start ..] and AfterTrial[Setup/Start ..] functions that need to be implemented in a similar way as the expeirment does.","title":"Trial flow"},{"location":"experiment/flow/#force-finishing-trial","text":"I provide special case for skipping or force finishing trials. Because sometimes quitting trial in a middle can have unexpected effects (for example you subscribed to an event and never unsubscribed, because that happens before trial is finished). Function TrialSetNext(int trialNumber) force finishes a trial. Default virtual behaviour is to FinishTrial() , but you can override this. Don't forget to FinishTrial() in the override (or call base);","title":"Force finishing trial"},{"location":"experiment/new-experiment/","text":"So you want to implement your first experiment? First go to the getting started section and try that the framework runs and logs. If you don\u00a8t encounter any issues, it is time to implement your first custom script. There are several staps you will need to do to create a new experiment in this framework. Create experiement class Create experiemnt settings class and creatting settings asset Setting up the scene according to your liking Modify the experiment class Creating experiment class Required functions Below is a complete list of functions that need to be implemented in the Expeirment flow. Many of these functions can effectively remain empty without hindering your expeirment performance. They are just there in case you need them. Experiment functions: public abstract void AddSettings ( ExperimentSettings settings ); void OnExperimentInitialise (); void AfterExperimentInitialise (); void OnExperimentSetup (); void AfterExperimentSetup (); void OnExperimentStart (); void AfterExperimentStart (); void OnExperimentFinished (); void AfterExperimentFinished (); void OnExperimentClosed (); void AfterExperimentClosed (); Trial functions: void OnTrialSetup (); void AfterTrialSetup (); void OnTrialStart (); void AfterTrialStart (); void OnTrialFinished (); void OnTrialForceFinished (){ FinishTrial ();}; void AfterTrialFinished (); void OnTrialClosed (); void AfterTrialClosed (); bool CheckForEnd (); Logging Functions: public abstract string ExperimentHeaderLog (); Creating experiment settings class Need - Settings object - Experiemnt manager - PlayerController - some sort of Place setting asset on the settings game object. When scene loads, this will get registered in the experiment manager","title":"New experiemnt"},{"location":"experiment/new-experiment/#creating-experiment-class","text":"","title":"Creating experiment class"},{"location":"experiment/new-experiment/#required-functions","text":"Below is a complete list of functions that need to be implemented in the Expeirment flow. Many of these functions can effectively remain empty without hindering your expeirment performance. They are just there in case you need them. Experiment functions: public abstract void AddSettings ( ExperimentSettings settings ); void OnExperimentInitialise (); void AfterExperimentInitialise (); void OnExperimentSetup (); void AfterExperimentSetup (); void OnExperimentStart (); void AfterExperimentStart (); void OnExperimentFinished (); void AfterExperimentFinished (); void OnExperimentClosed (); void AfterExperimentClosed (); Trial functions: void OnTrialSetup (); void AfterTrialSetup (); void OnTrialStart (); void AfterTrialStart (); void OnTrialFinished (); void OnTrialForceFinished (){ FinishTrial ();}; void AfterTrialFinished (); void OnTrialClosed (); void AfterTrialClosed (); bool CheckForEnd (); Logging Functions: public abstract string ExperimentHeaderLog ();","title":"Required functions"},{"location":"experiment/new-experiment/#creating-experiment-settings-class","text":"Need - Settings object - Experiemnt manager - PlayerController - some sort of Place setting asset on the settings game object. When scene loads, this will get registered in the experiment manager","title":"Creating experiment settings class"},{"location":"experiment/overview/","text":"Experiment class is the major part of this framework. It is a Unity component, that can be attached to an empty object, but it is usualy taken care of with ExperimentManager . It has a certain enforced flow that you can extend. This class is responsible for logging experiment state changes and events, keeping clear structure of function calls, keeps state of trials nad expeirment itself etc. Experiment Variables Variable Purpose Name Name of the experiment. important for serialisation TrialNumber Tracks the trial number. ExperimentNumber In case we are runnign multiple experiments at the same time. ExperimentState Tracks the state of the expeirment Events Event Purpose ExpeirmentEventSent Sends info about event being sent. Mostly for logging purposes. TrialStateChanged Sends info about change in trial state TrialEventSent Sends info for logging purposes. MessageSent Generic message event to logger. Functions Function Purpose StartExperiment Starts the expeirment if possible. TrialSetNext Sets the trial to the next one if possible. ForceNextTrial Forces next trial. ForceSetTrial Forces the trial to be set to designated number ForceFinishTrial Finishes the trial in any state FinishExperiment Finishes the expeirment immediately AddSettings Override to allow adding different settings to implemetned expeiremnts ExperimentHeaderLog Logs the speicific header for each expeirment Experiment Settings Class ExpeirmentSettings allow custom parameters for each expeirment. It allows serialisation and deserialisation and takes variable parameters according to your design. Experiment Results Class ExperimentResults is designed to take Attributes the class has two custom attributes [TestData] and [ResultData] to allow sequential and separate parsing. Just tag everything you want in your results as [ResultData] nad all the raw data as [TestData] . Unmarked values are not parsed in the Save() function.","title":"Overview"},{"location":"experiment/overview/#experiment","text":"","title":"Experiment"},{"location":"experiment/overview/#variables","text":"Variable Purpose Name Name of the experiment. important for serialisation TrialNumber Tracks the trial number. ExperimentNumber In case we are runnign multiple experiments at the same time. ExperimentState Tracks the state of the expeirment","title":"Variables"},{"location":"experiment/overview/#events","text":"Event Purpose ExpeirmentEventSent Sends info about event being sent. Mostly for logging purposes. TrialStateChanged Sends info about change in trial state TrialEventSent Sends info for logging purposes. MessageSent Generic message event to logger.","title":"Events"},{"location":"experiment/overview/#functions","text":"Function Purpose StartExperiment Starts the expeirment if possible. TrialSetNext Sets the trial to the next one if possible. ForceNextTrial Forces next trial. ForceSetTrial Forces the trial to be set to designated number ForceFinishTrial Finishes the trial in any state FinishExperiment Finishes the expeirment immediately AddSettings Override to allow adding different settings to implemetned expeiremnts ExperimentHeaderLog Logs the speicific header for each expeirment","title":"Functions"},{"location":"experiment/overview/#experiment-settings","text":"Class ExpeirmentSettings allow custom parameters for each expeirment. It allows serialisation and deserialisation and takes variable parameters according to your design.","title":"Experiment Settings"},{"location":"experiment/overview/#experiment-results","text":"Class ExperimentResults is designed to take","title":"Experiment Results"},{"location":"experiment/overview/#attributes","text":"the class has two custom attributes [TestData] and [ResultData] to allow sequential and separate parsing. Just tag everything you want in your results as [ResultData] nad all the raw data as [TestData] . Unmarked values are not parsed in the Save() function.","title":"Attributes"},{"location":"logging/master-log/","text":"void Instantiate(string participantId = null) public void StartLogging() public void StopLogging() public void CloseLogs()","title":"Master log"},{"location":"objects/arena-object-manager/","text":"Description Functions GetObject public ArenaObject GetObject(int i) Returns an object in the list if it exists at that particular index. Otherwise returns null. Show public void Show(int i) Calls Show on object at that particular index if it exists. ShowAll public void ShowAll(bool bo = true) Iterates thorugh all objects and calls Show(bo) at each controller. See Show . Hide public void Show(int i) Calls Hide on object at that particular index if it exists. HideAll public void HideAll() Same as ShowAll(false) . Runs Hide on all arena object controllers. See Hide . SetColor void SetColor(Color color) Sets colour of each obejct material if possible. See SetColor . SetType void SetType(string s, bool force = false) \u00a8 Iterates though objects and sets each object ot appropriate type as possible. See SetType .","title":"Arena object manager"},{"location":"objects/arena-object-manager/#description","text":"","title":"Description"},{"location":"objects/arena-object-manager/#functions","text":"","title":"Functions"},{"location":"objects/arena-object-manager/#getobject","text":"public ArenaObject GetObject(int i) Returns an object in the list if it exists at that particular index. Otherwise returns null.","title":"GetObject"},{"location":"objects/arena-object-manager/#show","text":"public void Show(int i) Calls Show on object at that particular index if it exists.","title":"Show"},{"location":"objects/arena-object-manager/#showall","text":"public void ShowAll(bool bo = true) Iterates thorugh all objects and calls Show(bo) at each controller. See Show .","title":"ShowAll"},{"location":"objects/arena-object-manager/#hide","text":"public void Show(int i) Calls Hide on object at that particular index if it exists.","title":"Hide"},{"location":"objects/arena-object-manager/#hideall","text":"public void HideAll() Same as ShowAll(false) . Runs Hide on all arena object controllers. See Hide .","title":"HideAll"},{"location":"objects/arena-object-manager/#setcolor","text":"void SetColor(Color color) Sets colour of each obejct material if possible. See SetColor .","title":"SetColor"},{"location":"objects/arena-object-manager/#settype","text":"void SetType(string s, bool force = false) \u00a8 Iterates though objects and sets each object ot appropriate type as possible. See SetType .","title":"SetType"},{"location":"objects/arena-object/","text":"Arena object controller Show public void Show(bool bo = true) Iterates thorugh all renderers and colliders of the ActiveObject and sets them to the bo parameter. Keeps trigger colliders active regardless. Hide public void Hide() Same as Show(false) . Iterates through renderers and colliders on the ActiveObject and disables them. Set rotation void SetRotation(Quaternion rotation) Sets ActiveObject to designated rotation. StartRotation void StartRotation(Vector3 direction, float speed) Starts rotation in direction at a given speed . If rotation is undergoing, it gets stopped and then reinstantiated. Direction of the rotation can be set using negative and positive vectors. StopRotation void StopRotation() If the object was rotating, it stops. SetSize void SetSize(Vector3 scale) Sets the scaling of the ActiveObject itself. Doesn't change scale of the controller object itself. SetColor void SetColor(Color color) Sets the main colour of the renderer material of hte Active object to designated colour. Any reset of colour is done towards the colour the object had during OnEnable call. SetType void SetType(string s, bool force = false) Sets the type of the object to one of children objects of the same name. Switch public bool Switch() Calls Show if the object is hidden and Hide if the object is shown. Retuns bool with the current state after the change.","title":"Arena object"},{"location":"objects/arena-object/#arena-object-controller","text":"","title":"Arena object controller"},{"location":"objects/arena-object/#show","text":"public void Show(bool bo = true) Iterates thorugh all renderers and colliders of the ActiveObject and sets them to the bo parameter. Keeps trigger colliders active regardless.","title":"Show"},{"location":"objects/arena-object/#hide","text":"public void Hide() Same as Show(false) . Iterates through renderers and colliders on the ActiveObject and disables them.","title":"Hide"},{"location":"objects/arena-object/#set-rotation","text":"void SetRotation(Quaternion rotation) Sets ActiveObject to designated rotation.","title":"Set rotation"},{"location":"objects/arena-object/#startrotation","text":"void StartRotation(Vector3 direction, float speed) Starts rotation in direction at a given speed . If rotation is undergoing, it gets stopped and then reinstantiated. Direction of the rotation can be set using negative and positive vectors.","title":"StartRotation"},{"location":"objects/arena-object/#stoprotation","text":"void StopRotation() If the object was rotating, it stops.","title":"StopRotation"},{"location":"objects/arena-object/#setsize","text":"void SetSize(Vector3 scale) Sets the scaling of the ActiveObject itself. Doesn't change scale of the controller object itself.","title":"SetSize"},{"location":"objects/arena-object/#setcolor","text":"void SetColor(Color color) Sets the main colour of the renderer material of hte Active object to designated colour. Any reset of colour is done towards the colour the object had during OnEnable call.","title":"SetColor"},{"location":"objects/arena-object/#settype","text":"void SetType(string s, bool force = false) Sets the type of the object to one of children objects of the same name.","title":"SetType"},{"location":"objects/arena-object/#switch","text":"public bool Switch() Calls Show if the object is hidden and Hide if the object is shown. Retuns bool with the current state after the change.","title":"Switch"},{"location":"objects/beeper-controller/","text":"Cotroller just holds a sounds to be played as well as string designation of the particular beeeper name. Variables BeeperName public string BeeperName; Sound public AudioClip sound; Function ReturnSound public AudioClip ReturnSound() Returns atatched AudioClip sound. I usualy played from BeeperManageer","title":"Beeper controller"},{"location":"objects/beeper-controller/#variables","text":"","title":"Variables"},{"location":"objects/beeper-controller/#beepername","text":"public string BeeperName;","title":"BeeperName"},{"location":"objects/beeper-controller/#sound","text":"public AudioClip sound;","title":"Sound"},{"location":"objects/beeper-controller/#function","text":"","title":"Function"},{"location":"objects/beeper-controller/#returnsound","text":"public AudioClip ReturnSound() Returns atatched AudioClip sound. I usualy played from BeeperManageer","title":"ReturnSound"},{"location":"objects/beeper-manager/","text":"When awake, it iterates through all its children and binds controller names so that it knows what it can play and what not. Monobehaviour Awake Iterates through all the children that have BeeperController script attached and get their names. It saves the name into BeeperControllers variable. Variables BeeperControllers public Dictionary<string, BeeperController> BeeperControllers List of all the BeeperController as well as their names as appears in BeeperName . Functions Play void Play(string beeperName) Tries to get a beepre controller of a certain name. If that controller exists, it plays one shot of that particular beeper. If not, returns KeyNotFoundException .","title":"Beeper manager"},{"location":"objects/beeper-manager/#monobehaviour","text":"","title":"Monobehaviour"},{"location":"objects/beeper-manager/#awake","text":"Iterates through all the children that have BeeperController script attached and get their names. It saves the name into BeeperControllers variable.","title":"Awake"},{"location":"objects/beeper-manager/#variables","text":"","title":"Variables"},{"location":"objects/beeper-manager/#beepercontrollers","text":"public Dictionary<string, BeeperController> BeeperControllers List of all the BeeperController as well as their names as appears in BeeperName .","title":"BeeperControllers"},{"location":"objects/beeper-manager/#functions","text":"","title":"Functions"},{"location":"objects/beeper-manager/#play","text":"void Play(string beeperName) Tries to get a beepre controller of a certain name. If that controller exists, it plays one shot of that particular beeper. If not, returns KeyNotFoundException .","title":"Play"},{"location":"objects/experiment-manager/","text":"Experiment manager takes care for the loading and control of the expeirment flow. You can load experiment through ExperimentLoader , but Experiment manager offers more to the pont clear loading experience. Experiment manager needs to be in the scene as it keeps track of hte Experiment active script and allows certain level of control over it. you shouldn't call experiment directly, just refere to expeirment manager to do all necessary changes and switches ot the Experiment flow. Functions StartExperiment public void StartExperiment() If the experiment is not runnign, it starts hte expeirment. StopExpeirment public void StopExperiment() Stops the experiment if the experiment is running. RestartExperiment public void RestartExperiment() Calls StopExpeirment and then StartExpoeirment , but it is broken after second iteration. Not sure why. SwitchExperimentState public void SwitchExperimentState() Does absolutely nothing at this point. SetTrial public void SetTrial(int i) Sets trial to the designated number. Finishes trial if running. Runs Tiral setup after setting the trial.","title":"Experiment manager"},{"location":"objects/experiment-manager/#functions","text":"","title":"Functions"},{"location":"objects/experiment-manager/#startexperiment","text":"public void StartExperiment() If the experiment is not runnign, it starts hte expeirment.","title":"StartExperiment"},{"location":"objects/experiment-manager/#stopexpeirment","text":"public void StopExperiment() Stops the experiment if the experiment is running.","title":"StopExpeirment"},{"location":"objects/experiment-manager/#restartexperiment","text":"public void RestartExperiment() Calls StopExpeirment and then StartExpoeirment , but it is broken after second iteration. Not sure why.","title":"RestartExperiment"},{"location":"objects/experiment-manager/#switchexperimentstate","text":"public void SwitchExperimentState() Does absolutely nothing at this point.","title":"SwitchExperimentState"},{"location":"objects/experiment-manager/#settrial","text":"public void SetTrial(int i) Sets trial to the designated number. Finishes trial if running. Runs Tiral setup after setting the trial.","title":"SetTrial"},{"location":"objects/goal-controller/","text":"Goal controller extends ArenaObject with all its functions. These are just goal specific extensions.","title":"Goal controller"},{"location":"objects/goal-manager/","text":"Goal manager extends ArenaObjectManager with all its functions. These are just goal specific extensions.","title":"Goal manager"},{"location":"objects/overview/","text":"Arena objects Arena objects are game objects with implemented functions for positionings, rotations etc. Arena objects come with Arena object manager as well, which allows grouping of controllers of the same type and doing madifications groupwise (such as setting same height or colour). Specific implementations of arena object is the Goal object ( Goal controller and Goal manager ) and mark object ( Mark controller and Mark manager ), see those sections for info. Arena object controller Arena obejct (AO) controller shoudl consist of a single empty game object with only controller script attached. It has PossibleObjects and ActiveObject parameters which are usually children obejcts, that AO can change \"into\". When creating an AO object, don't forget to add it's child object as well. Arena object shoudl have all colliders and mesh renderers in child objects, not on the same object where is the controller script. Variables Variable Purpose ActiveObject active game object if any PossibleObjects Contains an array of possible nested gameobjects to be played with with SetType . Can be set in unity Position Vector3 position in world coordinates Functions Function Purpose Show Shows the object and enables all non trigger collider. Hide If the ocject is visible, it becomes invisible SetRotation Sets the obejct rotation with the Quaternion. StartRotation Starts rotating the object in a given vector. StopRotation If the object is rotating, stops the rotation. SetSize Sets the scale according to passed vector. SetColor Sets the colour of the main material of the object. Saves the previous colour so you can call ResetColor() ResetColor resets the color to the original one. SetType Sets the object to the one desired, based on its string name. Switch Switches betwen visible and invisible state and returns the current state. Arena object manager Arena object manager allows to manage and controll all assigned controllers of a given type. Common practice is to have a single manager for each type of object that you have in scene. By defualt, Arena object manager is a singleton, so you can't have multiple in the same scene. If you need more, you can override the base class or create multiple child classes of distinct names out of the single implementation of a single manager (eg. Start manager can have two children, Star1Manager and Start2Manager which inherit from the a base class) Variables Variable Purpose Objects Generic list of all the obejct of the fiven type that manager holds. Functions Function Purpose ShowAll Shows the object and enables all non trigger collider. HideAll If the ocject is visible, it becomes invisible SetColor Sets the colour of all assigned objects. ResetColor resets the color to the original one. SetType Sets all assigned objects to the one desired, based on its string name. Goal Object Goal object adds some additional functionality to the arena object by adding event functionality. It inherits all the functionality from the Arena Object and Arena object Controller . Goal controller Goal controller (GC) extends Arena object controller but adds goal/target specific functinoality Variables Variable Purpose GoalName Holds the name of goal object. PlayerInside Holds the bool value of if player is inside the goal or not. Events Events Purpose OnEnter Is sent when player enters the goal object. OnExit Is sent when player exits the goal object. Goal manager Goal manager extend Arena object manager . It is a singleton that is used to manage and controll all referenced Goal Controllers . Variables Variable Purpose GetGoal Returns a Goal controller script given by index. ResizeGoals Resizes the local scale of all of the goals objects. InstantiateGoalsCircumference Instantiates goals attributes. Experiment manager Experiemnt manager is reponsible for loading expeirment from the data and manipulating expeirment states. Functions Function Purpose LoadExperiment initialises the expeirment form name and possible settings file. StartExperiment Starts the expeirment. StopExperiment Stops the expeirment. RestartExperiment Stops and then starts expperiment. buggy ATM. SwitchExperimentState Doens't do anything at this point. SetTrial Sets the trial to designated number. Player controllers PLayer controllers build upon the player controller and IPlayerController class to proovide bothe control as well as loggin informiaton necessary for conprehensive logs across differnet modalities of play (PC. VR, mobile etc.). Some functiuon needs to be implemented in order ot create sa new player log. Variables Variable Purpose Position Returns player position Rotation Returns player rotation Vector2Postition Returns player position in X and Z PointingDirection Returns rotation of player pointing. Functions Function Purpose MoveToCenter Generic list of all the obejct of the fiven type that manager holds. unstuck Tries to unlock player if they get stuck in mesh. EnableMovement Enables or disables movement EnableRotation Enables or disables rotation LookAtPosition Rotates player to face certain point SetHeight Sets player height SetSpeed Sets player speed Rigidbody player controller Beeper Beepers are designed to simply play sounds when certain events happen within the game. Beeper objects have beeper manager and beeper controlers. Beeper Manager BeeperManager takes care of cntrolling all attached controllers and plays souds based on string designation Variables Variable Function BeeperControlles list of all attached BeeperControllers. Function Function Function Play Plays one shot of the sounds in the controller Data holders Settings holder Input manager Console manager","title":"Overview"},{"location":"objects/overview/#arena-objects","text":"Arena objects are game objects with implemented functions for positionings, rotations etc. Arena objects come with Arena object manager as well, which allows grouping of controllers of the same type and doing madifications groupwise (such as setting same height or colour). Specific implementations of arena object is the Goal object ( Goal controller and Goal manager ) and mark object ( Mark controller and Mark manager ), see those sections for info.","title":"Arena objects"},{"location":"objects/overview/#arena-object-controller","text":"Arena obejct (AO) controller shoudl consist of a single empty game object with only controller script attached. It has PossibleObjects and ActiveObject parameters which are usually children obejcts, that AO can change \"into\". When creating an AO object, don't forget to add it's child object as well. Arena object shoudl have all colliders and mesh renderers in child objects, not on the same object where is the controller script.","title":"Arena object controller"},{"location":"objects/overview/#variables","text":"Variable Purpose ActiveObject active game object if any PossibleObjects Contains an array of possible nested gameobjects to be played with with SetType . Can be set in unity Position Vector3 position in world coordinates","title":"Variables"},{"location":"objects/overview/#functions","text":"Function Purpose Show Shows the object and enables all non trigger collider. Hide If the ocject is visible, it becomes invisible SetRotation Sets the obejct rotation with the Quaternion. StartRotation Starts rotating the object in a given vector. StopRotation If the object is rotating, stops the rotation. SetSize Sets the scale according to passed vector. SetColor Sets the colour of the main material of the object. Saves the previous colour so you can call ResetColor() ResetColor resets the color to the original one. SetType Sets the object to the one desired, based on its string name. Switch Switches betwen visible and invisible state and returns the current state.","title":"Functions"},{"location":"objects/overview/#arena-object-manager","text":"Arena object manager allows to manage and controll all assigned controllers of a given type. Common practice is to have a single manager for each type of object that you have in scene. By defualt, Arena object manager is a singleton, so you can't have multiple in the same scene. If you need more, you can override the base class or create multiple child classes of distinct names out of the single implementation of a single manager (eg. Start manager can have two children, Star1Manager and Start2Manager which inherit from the a base class)","title":"Arena object manager"},{"location":"objects/overview/#variables_1","text":"Variable Purpose Objects Generic list of all the obejct of the fiven type that manager holds.","title":"Variables"},{"location":"objects/overview/#functions_1","text":"Function Purpose ShowAll Shows the object and enables all non trigger collider. HideAll If the ocject is visible, it becomes invisible SetColor Sets the colour of all assigned objects. ResetColor resets the color to the original one. SetType Sets all assigned objects to the one desired, based on its string name.","title":"Functions"},{"location":"objects/overview/#goal-object","text":"Goal object adds some additional functionality to the arena object by adding event functionality. It inherits all the functionality from the Arena Object and Arena object Controller .","title":"Goal Object"},{"location":"objects/overview/#goal-controller","text":"Goal controller (GC) extends Arena object controller but adds goal/target specific functinoality","title":"Goal controller"},{"location":"objects/overview/#variables_2","text":"Variable Purpose GoalName Holds the name of goal object. PlayerInside Holds the bool value of if player is inside the goal or not.","title":"Variables"},{"location":"objects/overview/#events","text":"Events Purpose OnEnter Is sent when player enters the goal object. OnExit Is sent when player exits the goal object.","title":"Events"},{"location":"objects/overview/#goal-manager","text":"Goal manager extend Arena object manager . It is a singleton that is used to manage and controll all referenced Goal Controllers .","title":"Goal manager"},{"location":"objects/overview/#variables_3","text":"Variable Purpose GetGoal Returns a Goal controller script given by index. ResizeGoals Resizes the local scale of all of the goals objects. InstantiateGoalsCircumference Instantiates goals attributes.","title":"Variables"},{"location":"objects/overview/#experiment-manager","text":"Experiemnt manager is reponsible for loading expeirment from the data and manipulating expeirment states.","title":"Experiment manager"},{"location":"objects/overview/#functions_2","text":"Function Purpose LoadExperiment initialises the expeirment form name and possible settings file. StartExperiment Starts the expeirment. StopExperiment Stops the expeirment. RestartExperiment Stops and then starts expperiment. buggy ATM. SwitchExperimentState Doens't do anything at this point. SetTrial Sets the trial to designated number.","title":"Functions"},{"location":"objects/overview/#player-controllers","text":"PLayer controllers build upon the player controller and IPlayerController class to proovide bothe control as well as loggin informiaton necessary for conprehensive logs across differnet modalities of play (PC. VR, mobile etc.). Some functiuon needs to be implemented in order ot create sa new player log.","title":"Player controllers"},{"location":"objects/overview/#variables_4","text":"Variable Purpose Position Returns player position Rotation Returns player rotation Vector2Postition Returns player position in X and Z PointingDirection Returns rotation of player pointing.","title":"Variables"},{"location":"objects/overview/#functions_3","text":"Function Purpose MoveToCenter Generic list of all the obejct of the fiven type that manager holds. unstuck Tries to unlock player if they get stuck in mesh. EnableMovement Enables or disables movement EnableRotation Enables or disables rotation LookAtPosition Rotates player to face certain point SetHeight Sets player height SetSpeed Sets player speed","title":"Functions"},{"location":"objects/overview/#rigidbody-player-controller","text":"","title":"Rigidbody player controller"},{"location":"objects/overview/#beeper","text":"Beepers are designed to simply play sounds when certain events happen within the game. Beeper objects have beeper manager and beeper controlers.","title":"Beeper"},{"location":"objects/overview/#beeper-manager","text":"BeeperManager takes care of cntrolling all attached controllers and plays souds based on string designation","title":"Beeper Manager"},{"location":"objects/overview/#variables_5","text":"Variable Function BeeperControlles list of all attached BeeperControllers.","title":"Variables"},{"location":"objects/overview/#function","text":"Function Function Play Plays one shot of the sounds in the controller","title":"Function"},{"location":"objects/overview/#data-holders","text":"","title":"Data holders"},{"location":"objects/overview/#settings-holder","text":"","title":"Settings holder"},{"location":"objects/overview/#input-manager","text":"","title":"Input manager"},{"location":"objects/overview/#console-manager","text":"","title":"Console manager"},{"location":"objects/player-controller/","text":"Player controller is an abstract class that is extended by default in teh package by rigidbody player controller. It derives from Singleton class, which means it can only have a single instance within each scense. The idea behind abstract classes should solve issues with cusom logging and suctom functions that are implemented differnetly for 2D and 3D screesn as possibly for mobile screens. Therefore functions below are not necessarilly implemented by default adn you are invited to implemtnt them as you see fit when modifying the player contrller in your won project. Variables Rotation Vector2 Rotation {get;} Returns Vector2 euler angles of World coordinate rotation of the player and camera. X coordinate is 360 calculated with the zero vector of Vector3.Forward, Y coordinate is camera rotation. Setting rotation can be done with LookAtPosition , as it's rather tricky. Position Vector3 Postition {get; set;} Returns position of the player instance. Vector2 Vector2Postition {get; set;} Returns only X and Z position of Vector3 position. PointingDirection Vector2 PointingDirection { get; } Returns pointing direction of the player in eulerAngles. Useful for implementation of VR paradigms, where we can use controllers rather than camera to point. In basic Rigidbody implementation it is evvectively same as Rotation. Functions MoveToCenter void MoveToCenter() Useful in experiments where the beginning of trials is positioned at the Vector3(0, y, 0) coordinates. Moves player to the center position while keeping the y axis constant. MoveToPosition void MoveToPosition(Vector2 position) Moves player to X and Z world position while keeping the Y axis constant. Unstuck void Unstuck() Moves player one bit towards default(Vector3) . Should fix any situations where the player gets stuck in walls EnableRotation void EnableRotation(bool bo = true) Enables or disables rotation of the player- LookAtPosition void LookAtPosition(Vector3 point) Rotates player and camera to look at a particular point in World coordinates void LookAtPosition(Vector2 point) Same as previous, but keeps the camera Y axis. Only turns/rotates in horizontal level. SetHeight void SetHeight(float height) Defines height of the camera in the world view. Usually doesn't modify the colider, but you can implement it if you need. SetSpeed void SetSpeed(float speed) Sets the speed of player controller to designated float. The speed itself is modified within each controller. Float shoudl be within 0-100, as the attached player controller UI actually only takes these numbers, but you need to define it depending on what controller you are using. HeaderLine string HeaderLine() Necessary to implement the IPlayerController interface for logging purposes. Basically defines column names for the controler to log with PlayerInformation . Column names need to be separated by ; and the string shoudl end with ; . Example public override string HeaderLine() { return \"Position; Rotation.X; Rotation.Y;\"; } PlayerInformation List<string> PlayerInformation() Returns a list with all the information you want to log about hte player every time player information gets logged. This information should correspond to the HeaderLine Example var strgs = new List<string> { Position.ToString(\"F4\"), Rotation.x.ToString(\"F4\"), Rotation.y.ToString(\"F4\") }; return strgs; Rigidbody Functions Stop void Stop()","title":"Player controller"},{"location":"objects/player-controller/#variables","text":"","title":"Variables"},{"location":"objects/player-controller/#rotation","text":"Vector2 Rotation {get;} Returns Vector2 euler angles of World coordinate rotation of the player and camera. X coordinate is 360 calculated with the zero vector of Vector3.Forward, Y coordinate is camera rotation. Setting rotation can be done with LookAtPosition , as it's rather tricky.","title":"Rotation"},{"location":"objects/player-controller/#position","text":"Vector3 Postition {get; set;} Returns position of the player instance. Vector2 Vector2Postition {get; set;} Returns only X and Z position of Vector3 position.","title":"Position"},{"location":"objects/player-controller/#pointingdirection","text":"Vector2 PointingDirection { get; } Returns pointing direction of the player in eulerAngles. Useful for implementation of VR paradigms, where we can use controllers rather than camera to point. In basic Rigidbody implementation it is evvectively same as Rotation.","title":"PointingDirection"},{"location":"objects/player-controller/#functions","text":"","title":"Functions"},{"location":"objects/player-controller/#movetocenter","text":"void MoveToCenter() Useful in experiments where the beginning of trials is positioned at the Vector3(0, y, 0) coordinates. Moves player to the center position while keeping the y axis constant.","title":"MoveToCenter"},{"location":"objects/player-controller/#movetoposition","text":"void MoveToPosition(Vector2 position) Moves player to X and Z world position while keeping the Y axis constant.","title":"MoveToPosition"},{"location":"objects/player-controller/#unstuck","text":"void Unstuck() Moves player one bit towards default(Vector3) . Should fix any situations where the player gets stuck in walls","title":"Unstuck"},{"location":"objects/player-controller/#enablerotation","text":"void EnableRotation(bool bo = true) Enables or disables rotation of the player-","title":"EnableRotation"},{"location":"objects/player-controller/#lookatposition","text":"void LookAtPosition(Vector3 point) Rotates player and camera to look at a particular point in World coordinates void LookAtPosition(Vector2 point) Same as previous, but keeps the camera Y axis. Only turns/rotates in horizontal level.","title":"LookAtPosition"},{"location":"objects/player-controller/#setheight","text":"void SetHeight(float height) Defines height of the camera in the world view. Usually doesn't modify the colider, but you can implement it if you need.","title":"SetHeight"},{"location":"objects/player-controller/#setspeed","text":"void SetSpeed(float speed) Sets the speed of player controller to designated float. The speed itself is modified within each controller. Float shoudl be within 0-100, as the attached player controller UI actually only takes these numbers, but you need to define it depending on what controller you are using.","title":"SetSpeed"},{"location":"objects/player-controller/#headerline","text":"string HeaderLine() Necessary to implement the IPlayerController interface for logging purposes. Basically defines column names for the controler to log with PlayerInformation . Column names need to be separated by ; and the string shoudl end with ; . Example public override string HeaderLine() { return \"Position; Rotation.X; Rotation.Y;\"; }","title":"HeaderLine"},{"location":"objects/player-controller/#playerinformation","text":"List<string> PlayerInformation() Returns a list with all the information you want to log about hte player every time player information gets logged. This information should correspond to the HeaderLine Example var strgs = new List<string> { Position.ToString(\"F4\"), Rotation.x.ToString(\"F4\"), Rotation.y.ToString(\"F4\") }; return strgs;","title":"PlayerInformation"},{"location":"objects/player-controller/#rigidbody","text":"","title":"Rigidbody"},{"location":"objects/player-controller/#functions_1","text":"","title":"Functions"},{"location":"objects/player-controller/#stop","text":"void Stop()","title":"Stop"}]}